## :round_pushpin: Network

***

<br> 

### :pushpin: 프로토콜이란?

- 컴퓨터 간에 교환되는 메시지 형식, 순서 등을 정의한 것



### :pushpin: DNS(Domain Name Service)란?

- 사람이 알아보기 쉬운 도메인 주소를 컴퓨터가 사용하는 IP 주소로 변환하는 서비스
- www.naver.com뒤에 보이지 않는 .(dot)이 붙어있음, www.naver.com.
  - **.(dot)** 은 **Root**라는 뜻 
- **도메인 네임 스페이스**, **네임 서버**, **리졸버**로 이루어짐
  - **도메인 네임 스페이스** : 최상위 Root DNS 서버 존재, 하위로 노드가 연속해서 이어진 계층구조
  - **네임 서버** : 도메인 네임 스페이스의 트리구조에 대한 정보가 필요, 도메인 이름을 IP로 변환
  - **리졸버** : 클라이언트 요청을 네임 서버로 전달, 네임 서버로부터 도메인 이름과 IP를 클라이언트에게 전달하는 기능 수행

<br> 

### :pushpin: DNS 동작 과정

1. **웹 브라우저**에서 **로컬 DNS 서버**에 접속하려는 도메인에 대한 IP 주소를 질의
2. [1]번에서 **로컬 DNS 서버**는 클라이언트가 요청한 도메인 주소가 없다면, **Root DNS** 서버로 질의를 전달
3. **Root DNS** 서버는 로컬 DNS 서버의 질의에 해당하는 주소가 없으면 그 도메인 주소를 관리하는 **네임 서버**의 이름과 **IP주소**를 **로컬 DNS 서버**에 전달
4. **로컬 DNS 서버**는 해당 도메인을 관리하는 **네임 서버**에 다시 질의를 하게 되고, 이런식으로 각 도메인 이름을 관리하는 **네임 서버**에 질의하여 해당 도메인과 일치하는 IP 주소를 **로컬 DNS**가 받게 되고, **웹 브라우저**에 알려준다. 

<br>

### :pushpin: Local DNS Server에 웹 브라우저에서 질의한 도메인에 대한 IP주소가 없는 경우

![Untitled Diagram drawio](https://user-images.githubusercontent.com/55940552/146681047-712977bf-560d-4440-b8dd-b414a4ffe536.png) 

<br>

### :pushpin: TCP/IP 5계층

1. **물리** : 물리적 연결과 전기 신호 변환 및 제어(비트 전송)
2. **데이터 링크** : MAC 주소로 통신, 물리적 네트워크 사이에 데이터 전송을 담당
3. **네트워크** : 네트워크 경로 설정, 논리 주소 결정(IP라는 개념이 존재, ARP, RARP, ICMP 등)
4. **전송** : 네트워크 계층의 데이터를 정렬, 오류 수정, 신뢰 가능한 통신 확보(TCP, UDP 개념 존재)
5. **응용** : 이메일, 웹 브라우저, 파일 전송 등의 서비스 제공



### :pushpin: OSI 7계층

1. **물리** : 기계적, 전기적 신호를 통한 비트 전송
2. **데이터 링크** : 네트워크 기기 간에 데이터 전송 및 물리주소 결정(MAC, Ethernet)
3. **네트워크** : 네트워크 경로 설정, 논리 주소 결정(IP, Router, ARP, RARP, ICMP 등)
4. **전송** : 데이터를 전송하고 전송 속도를 조절, 오류 발생시 다시 맞춰주는 계층
   - 헤더에 송수신지 포트번호를 포함하여 상위 계층에 전송
5. **세션** : 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공(전이중, 반이중 통신 등)
6. **표현** : 응용 프로그램에서 데이터 의미 해석(암호화, 압축 등), 사용자의 명령어 완성 및 결과 표현
7. **응용** : 사용자가 네트워크에 접근할 수 있도록 인터페이스를 지원

<br>

### :pushpin: Session과 Cookie의 차이

- **HTTP 프로토콜의 약점을 보완하기 위해 사용**
  - 비연결지향 : 클라이언트가 서버에 요청 시, 그 요청에 맞는 응답 후 연결을 끊는 방식
    - HTTP 1.1v 에서 연결 유지 및 재활용 기능이 Default로 추가됨
  - 상태정보 유지 안함 : 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식
- **Cookie** 
  - 사용자가 웹 사이트 방문 시 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
  - HTTP에서 클라이언트의 정보를 클라이언트의 PC에 저장했다가 필요시 참조하거나 재사용 가능
- **Session**
  - 각 클라이언트에 Session ID를 부여하고, 웹 브라우저가 서버에 접속해서 종료할 때 까지 인증 상태를 유지
  - 사용자 정보 파일을 서버 측에 저장하고 관리
  - 보안에 좋지만, 서버의 리소스를 사용한다는 단점
- **차이점**
  - 세션이 보안 측면에서 쿠키보다 좋음
    - 서버의 보안이 클라이언트 보안보다 우수하기 때문
  - 정보가 저장되는 위치적 측면에서 쿠키는 클라이언트의 웹 브라우저에, 세션은 서버에 저장됨
  - 쿠키는 만료기간 전까지 남아있지만, 세션은 브라우저가 종료되면 삭제된다.
  - 쿠키는 HTTP 메시지에 담아 보내고, 세션은 서버에서 처리가 필요하기 때문에 요청속도 측면에서는 쿠키가 더 빠르다.

<br>

### :pushpin: Hosting

- 서버의 전체 혹은 일부를 이용할 수 있도록 임대해주는 서비스
- **종류**
  - **웹 호스팅** : 여러 고객이 하나의 서버를 함께 사용하는 형태
  - **서버 호스팅** : 고객이 단독 서버를 사용하는 형태, 서버 운영 및 관리에 대한 직접적인 권한을 가질 수 있다.
  - **클라우드 서버** : 서버 호스팅을 가상화한 것, 가상 서버를 단독으로 사용할 수 있는 형태

<br>

### :pushpin: 부하분산(Load Balancing)

- 컴퓨터 네트워크 기술의 일종
- 둘 혹은 셋 이상의 CPU 또는 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미

<br>



### :pushpin: 프로세스와 스레드

- **프로세스**
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 등록되어 실행되고 있는 프로그램의 인스턴스
  - OS로부터 자원을 할당받는 작업의 단위
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
  - 기본적으로 프로세스당 **최소 1개의 스레드**를 가지고 있음
- **스레드**
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스 내에서 각각 **Stack 메모리만 할당** 받고, **Code, Data, Heap 영역**은 서로 **공유**한다.

<br>

### :pushpin: 가상 사설 서버(VPS)

- 하나의 물리 서버를 여러 개의 가상 서버로 쪼개어 사용하는 것을 의미
- 쪼개어진 가상 서버를 여러 클라이언트가 나누어 사용하는 것

<br>

### :pushpin: SSL(Secure Socket Layer)란

- 웹 서버와 웹 브라우저간의 보안을 위해 만들어진 암호화 프로토콜
- 공개키/개인키, 대칭키 기반 암호화 사용
  - 대칭키 : 세션 키값을 이용해서 대칭키 방식으로 데이터 암호화 
  - 공개키/개인키 : 계산하는데 복잡하고, 시간복잡도가 높으므로 세션 키를 주고 받을 떄 클라이언트가 3 way handshaking 과정에서 받은 웹 서버의 공개키로 세션 키를 암호화하고, 웹 서버는 자신의 개인키로 복호화 한 후에 세션 키를 대칭 키로 하여 암호화 후 데이터 송수신

<br>

### :pushpin: TLS란

- SSL 3.0을 기반으로 만들어진 웹 서버와 브라우저 간에 암호화 프로토콜

<br>

### :pushpin: IP주소

- **32bit = 4byte**

- ex) 192.128.1.14 

- 범위가 크기 때문에 총 5개 클래스로 나뉨

  - **유니케스트**할 때 사용하는 클래스 : A, B, C 클래스

    - **유니케스트 : ** 1:1 통신 방식(일반적인 인터넷 응용프로그램이 사용)

  - **A Class** : 0.0.0.0 ~ 127.255.255.255(0 ~ 127)

    - **0**000 0000 ~ **0**111 1111(맨 앞에 비트)

  - **B Class** : 128.0.0.0 ~ 191.255.255.255(128 ~ 191)

    - **10**00 0000 ~ **10**11 1111(맨 앞에서 두 비트)

  - **C Class** : 192.0.0.0 ~ 223.255.255.255(192 ~ 223)

    - **110**0 0000 ~ **110**1 1111(맨 앞에서 세 비트)

    > **128보다 작으면 A 클래스, 191보다 크면 C클래스**

  - **멀티케스트**할 떄 사용하는 클래스 : D 클래스

    - **멀티케스트 : ** 1:N 통신 방식
    - 서브넷 마스크 개념이 없음
    - **D Class** : 224.0.0.0 ~ 239.255.255.255(224 ~ 239)
      - **1110** 0000 ~ **1110** 1111(맨 앞에 네 비트가 1110인 공통 비트를 가진 클래스)

  - **IANA 예비용 예약 주소** 클래스 : E 클래스

    - **E Class** : 240.0.0.0 ~ 255.255.255.255(240 ~ 255)
    - 사용하지 않는 주소, 예비용

- **설정이 불가능한 IP 주소**

  - **예약 주소** : D Class(사용 가능, 설정 불가)
  - **멀티캐스트 주소** : E Class(사용 불가, 설정 불가)
  - **0.x.x.x(0으로 시작하는 주소)** : 사용 불가, 설정 불가
  - **127.0.0.1(루프백 주소)** : 사용 가능, 설정 불가
  - **네트워크 이름, 서브넷 브로드캐스트 주소** : 사용 가능, 설정 불가



<br>

### :pushpin: 서브넷이란?

- 네트워크 아이디와 호스트 아이디를 구별하기 위함(네트워크 아이디당 가질 수 있는 IP 주소 개수)

- **각 클래스와 서브넷 마스크는 상관없음**
  - **/8 서브넷 마스크** : 255.0.0.0
    - **네트워크 아이디** : 0~127
    - **호스트 아이디** : 0.0.0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0.0.0 이므로 2^8승이 3개, 총 2^24승개
  - **/16 서브넷 마스크** : 255.255.0.0
    - **네트워크 아이디** : 128.0 ~ 191.255
    - **호스트 아이디** : 0.0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0.0 이므로 2^8승이 2개, 총 2^16승개
  - **/24 서브넷 마스크** : 255.255.255.0
    - **네트워크 아이디** : 192.0.0 ~ 223.255.255
    - **호스트 아이디** : 0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0 이므로 2^8승이 1개, 총 2^8승 개
  - **ex) IP 주소 : 121.160.54.233, 서브넷 마스크 : 255.255.255.0**
    - 121 이므로 A 클래스
    - A 클래스지만 네트워크 ID를 121.160.54로 사용중
    - A 클래스에 255.0.0.0 서브넷 마스크는 너무 많은 IP 주소를 가지므로 네트워크 ID를 줄이고 적은 호스트 ID를 사용하는 것
  - **ex) 192.168.0.1/24**
    - 192 이므로 C 클래스
    - /24 이므로 255.255.255.0 서브넷 마스크를 가짐
      - 서브넷 마스크 앞에서부터 2^24승 이므로 2^8승이 3개, 255.255.255.0이 되는 것

<br>

### :pushpin: ARP 프로토콜

- 같은 네트워크 대역에서 통신하기 위해 필요한 MAC 주소를 IP를 이용해서 알아오는 프로토콜
  - 같은 네트워크 대역에서 통신할 때는 MAC주소를 통해 통신한다.
- IP주소를 통해 얻은 MAC주소로 상대방과 통신하는 것(상대방의 MAC주소를 모를 때)
- 같은 네트워크 대역에서 통신을 하더라도 7계층부터 캡슐화를 통해 보내기 때문에 IP와 MAC 주소가 모두 필요함, 이때 상대방 MAC주소를 모르더라도 ARP를 통해 MAC주소를 알아오고 통신이 가능해짐
- 요청은 1, 응답은 2로 opcode를 세팅한다.
- **동작 과정**
  - 통신을 요청하고자 하는 컴퓨터에서 ARP 요청 프로토콜을 만듬
    - (이더넷 헤더+ARP요청 프로토콜)
    - 이더넷 헤더 캡슐화 : 목적지 MAC 주소를 FF:FF:FF:FF:FF:FF로 작성(브로드캐스팅)
    - ARP 요청 헤더 헤더 : 이때 출발지 MAC주소와 IP주소는 자신의 것으로 삽입, 목적지 MAC주소는 00:00:00:00:00:00으로 비운다.
  - 2계층 장비인 스위치를 거치기 때문에 이더넷 헤드만 확인하여 같은 네트워크 대역에 브로드캐스팅
  - 해당 패킷을 받은 컴퓨터들은 3계층인 ARP 요청 헤더를 확인
  - 본인의 IP주소와 해당 패킷의 목적지 IP주소가 불일치하면 폐기
  - 자신의 IP주소와 해당 패킷의 목적지 IP주소가 일치하면 이더넷 헤더와 ARP 응답 헤더를 생성
    - 이더넷 헤더와 ARP 헤더에 출발지 MAC 주소에 자신의 MAC주소를 작성함
    - 목적지 MAC 주소는 자신에게 ARP요청 헤더를 보냈던 컴퓨터의 MAC 주소를 기재
  - 이후 통신을 요청한 컴퓨터의 ARP 캐시 테이블에 IP주소와 MAC주소를 등록

<br>

### :pushpin: ICMP 프로토콜

- TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알려주는 프로토콜
  - IP에는 패킷을 목적지에 보내기 위한 내용들로만 구성되어있음

<br>

### :pushpin: SNMP 프로토콜

- 네트워크 관리 및 모니터링 프로토콜
- 관리 시스템과 관리 대상(Agent)으로 나뉨
  - 관리 대상(Agen)의 구성
    - SNMP : 전송 프로토콜
    - MIB : 관리할 개체의 집합
    - SMI : 관리 방법

<br>

### :pushpin: IGMP 프로토콜

- 멀티캐스트 그룹 관리 프로토콜
  - 유니캐스트 : 1대 1
  - 브로드 캐스트 : 1대 N
  - 멀티 캐스트 : N대 M

<br> 

### :pushpin: 스위치(2계층 장비)

- 패킷의 2계층 까지만 확인

<br>

### :pushpin: 소켓이란?

- 네트워크 접속 및 소프트웨어 간의 연결 도구
- 프로세스 간에 메시지 송수신할 때 소켓을 사용
- OS에서 제공하는 소프트웨어적 장치
- 운영체제에서 제공하는 소켓을 이용하여 네트워크로 컴퓨터 간에 데이터 송수신을 위한 통신이 가능

<br>

### :pushpin: 서버란?

- 연결요청을 허용하는 프로그램

<br>

### :pushpin: 파일디스크립터

- OS가 만든 소켓을 구분하기 위한 숫자
- 유닉스에서 소켓은 파일처럼 관리된다.

<br>

### :pushpin: CSMA/CD 통신방식

- 다른 PC에서 보낸 패킷과의 충돌이 발생할 수 있으므로 LAN 케이블을 감시하여 패킷이 없는 경우에만 전송

<br>

### :pushpin: 포트 포워딩

- 공유기를 기준으로 외부 IP에서 내부 IP의 특정 서비스에 접근하기 위해 IP와 Port를 공유기에 지정하는 것

<br>

### :pushpin: OSI 7계층 나눈 이유

- PC 방에서 오버워치를 하는데 연결이 끊김
  - 모든 PC에 문제가 있다면?
    - 라우터(3계층) 또는 광랜을 제공하는 회사의 회선 문제(1계층)
  - 하나의 PC에 문제가 있고 오버워치 소프트웨어에 문제가 있다면?
    - 소프트웨어의 문제(7계층)
    - 소프트웨어에 문제가 없다면?(2계층)
- 각 계층별로 오류를 판단해 다른 계층에 영향을 주지 않게 하기 위함

<br>

### :pushpin: 라우팅과 포워딩

- **라우팅(네트워크 계층의 제어 영역)**
  - 패킷의 출발지와 목적지 전체 경로를 설정
  - 패킷은 라우터 버퍼의 큐에서 대기
  - **라우팅 알고리즘**으로 설정(다익스트라, 벨만포드)
    - 전통적 라우팅 알고리즘 : 각 라우터 내 구현, 개별 운영 라우팅 알고리즘(OSPF, BGP)
    - 소프트웨어 정의 네트워킹(SDN) : 외부 원격제어기에 구현하고 라우터들에게 할당하는 방식
- **포워딩(네트워크 계층의 데이터 영역)**
  - 라우터에 들어온 패킷을 적절한 출력단으로 전송
- **라우터 스케줄링 규칙**
  - **우선순위 스케줄링** : 최우선순위 패킷 먼저 전송
  - **FIFO 스케줄링** : 큐에 도착하는 순서대로 전송
  - **라운드 로빈 스케줄링** : 클래스별 큐를 주기적으로 스캔, 큐에 도착한 완전한 패킷을 먼저 전송
  - **가중치 공정 큐잉 스케줄링** : 각 클래스는 사이클마다 일정 가중치 서비스 양을 부여 받는다.

<br>

### :pushpin: 회선 교환 방식

- FDM(주파수 분할 다중화)
  - 주파수 대역대를 분리하여 같은 시간에 여러 사용자가 회선 사용 가능
- TDM(시분할 다중화)
  - 여러 사용자의 회선 사용 시간을 나누어서 지속적으로 보내는 것

<br>

### :pushpin: 패킷 교환 방식

- 작은 블록의 패킷으로 데이터를 전송하는 방식
- 데이터를 전송하는 동안만 네트워크 자원을 사용하도록 하는 방법
- **패킷 지연**
  - 노드 처리 지연
  - 큐잉 지연
  - 전파 지연
  - 전송 지연

<br>

### :pushpin: Traceroute 프로그램

- 송신지에서 목적지까지 경로와 발생하는 지연 측정

<br>

### :pushpin: 프록시란?

- 두 지점간의 통신에서 대리로 통신을 수행하는 기능

<br>

### :pushpin: 웹 캐시(프록시 서버)

- 원본 서버의 개입없이 클라이언트의 요청을 처리
- 초기 접속에서 브라우저는 웹 캐시를 통해 원본 서버에 접속
- 이후 브라우저는 HTTP 요청을 웹 캐시로 전송
  - 웹 캐시 내부에 객체가 존재하면 해당 객체를 반환
  - 웹 캐시 내부에 객체가 존재하지 않는다면, 웹 캐시는 원본 서버에 객체를 요청, 수신 후 클라이언트에게 전달
- 클라이언트 요청의 응답 시간 최소화를 위해 사용

<br>

### :pushpin: 전자 메일

- 사용자 에이전트, 메일 서버, SMTP 프로토콜
- **사용자 에이전트**
  - 메일 송수신
- **메일 서버**
  - 메일 박스 : 사용자에 전달할 수신 메시지 보관
  - 메시지 큐 : 외부 사용자에 전송할 메시지 보관
- **SMTP 프로토콜 (메일 교환 프로토콜)**
  - 메일 서버 간에 메일 전송
  - TCP(port 25)를 사용하여 신뢰성있는 메시지 전송
  - 클라이언트가 User Agent를 통해 메일을 작성하고 보내면, 해당 클라이언트의 메일 서버의 메시지 큐에 삽입되고, 상대 메일 서버와 TCP 연결 이후 SMTP 프로토콜을 사용하여 메시지 전송, 이후 상대 메일 서버는 상대방 메일 박스에 저장, 상대방은 자신의 User Agent를 통해 메시지를 읽음
- **IMAP, POP3 (메일 사용 프로토콜)**
  - **IMAP**
    - 세션 중 연결 상태 저장
    - 서버에 모든 메시지 저장
  - **POP 3**
    - 세션 중 연결 상태 저장안됨
    - 클라이언트가 서버에서 다운로드하면 자동 삭제



<br>

### :pushpin: 동적 호스트 구성 프로토콜(DHCP : Dynamic Host Configuration Protocol)

- IP를 관리하는 특정 서버로부터 동적으로 주소를 제공 받아 설정하고 사용하기 위한 프로토콜
- 사용 중인 주소는 임대기간 이후 갱신
- UDP, IP, Ethernet 순으로 캡슐화 후 DHCP 요청, 응답 진행

<br>

### :pushpin: TCP 혼잡 제어 알고리즘

- **기본** : AIMD(합증가/곱감소) : 문제 발생까지 cwnd를 1씩 증가, 발생 시 반으로 감소
  1. **슬로우 스타트**
     - 첫 손실까지 전송률 지수적 증가
  2. **혼잡 회피**
     - 전송한 데이터에 대한 ACK를 받으면 cwnd를 1씩 증가, 문제 발생 시 반으로 감소(빠른 회복)
  3. **빠른 회복**
     - 혼잡 상태 시 cwnd를 반으로 감소시키고 선형적으로 증가시키는 방법