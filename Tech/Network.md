## :round_pushpin: Network

***

<br> 

### :pushpin: DNS(Domain Name Service)란?

- 사람이 알아보기 쉬운 도메인 주소를 컴퓨터가 사용하는 IP 주소로 변환하는 서비스
- www.naver.com뒤에 보이지 않는 .(dot)이 붙어있음, www.naver.com.
  - **.(dot)** 은 **Root**라는 뜻 
- **도메인 네임 스페이스**, **네임 서버**, **리졸버**로 이루어짐
  - **도메인 네임 스페이스** : 최상위 Root DNS 서버 존재, 하위로 노드가 연속해서 이어진 계층구조
  - **네임 서버** : 도메인 네임 스페이스의 트리구조에 대한 정보가 필요, 도메인 이름을 IP로 변환
  - **리졸버** : 클라이언트 요청을 네임 서버로 전달, 네임 서버로부터 도메인 이름과 IP를 클라이언트에게 전달하는 기능 수행

<br> 

### :pushpin: DNS 동작 과정

1. **웹 브라우저**에서 **로컬 DNS 서버**에 접속하려는 도메인에 대한 IP 주소를 질의
2. [1]번에서 **로컬 DNS 서버**는 클라이언트가 요청한 도메인 주소가 없다면, **Root DNS** 서버로 질의를 전달
3. **Root DNS** 서버는 로컬 DNS 서버의 질의에 해당하는 주소가 없으면 그 도메인 주소를 관리하는 **네임 서버**의 이름과 **IP주소**를 **로컬 DNS 서버**에 전달
4. **로컬 DNS 서버**는 해당 도메인을 관리하는 **네임 서버**에 다시 질의를 하게 되고, 이런식으로 각 도메인 이름을 관리하는 **네임 서버**에 질의하여 해당 도메인과 일치하는 IP 주소를 **로컬 DNS**가 받게 되고, **웹 브라우저**에 알려준다. 

<br>

### :pushpin: Local DNS Server에 웹 브라우저에서 질의한 도메인에 대한 IP주소가 없는 경우

![Untitled Diagram drawio](https://user-images.githubusercontent.com/55940552/146681047-712977bf-560d-4440-b8dd-b414a4ffe536.png) 

<br>

### :pushpin: TCP/IP 5계층

1. **물리** : 물리적 연결과 전기 신호 변환 및 제어
2. **데이터 링크** : 네트워크 기기 간에 데이터 전송 및 물리 주소(Mac) 결정
3. **네트워크** : 네트워크 경로 설정, 논리 주소 결정(IP라는 개념이 존재)
4. **전송** : 네트워크 계층의 데이터를 정렬, 오류 수정, 신뢰 가능한 통신 확보(TCP, UDP 개념 존재)
5. **응용** : 이메일, 웹 브라우저, 파일 전송 등의 서비스 제공

<br> 

### :pushpin: ARP 란?



<br>



### :pushpin: Session과 Cookie의 차이

- **HTTP 프로토콜의 약점을 보완하기 위해 사용**
  - 비연결지향 : 클라이언트가 서버에 요청 시, 그 요청에 맞는 응답 후 연결을 끊는 방식
    - HTTP 1.1v 에서 연결 유지 및 재활용 기능이 Default로 추가됨
  - 상태정보 유지 안함 : 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식
- **Cookie** 
  - 사용자가 웹 사이트 방문 시 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
  - HTTP에서 클라이언트의 정보를 클라이언트의 PC에 저장했다가 필요시 참조하거나 재사용 가능
- **Session**
  - 각 클라이언트에 Session ID를 부여하고, 웹 브라우저가 서버에 접속해서 종료할 때 까지 인증 상태를 유지
  - 사용자 정보 파일을 서버 측에 저장하고 관리
  - 보안에 좋지만, 서버의 리소스를 사용한다는 단점
- **차이점**
  - 세션이 보안 측면에서 쿠키보다 좋음
    - 서버의 보안이 클라이언트 보안보다 우수하기 때문
  - 정보가 저장되는 위치적 측면에서 쿠키는 클라이언트의 웹 브라우저에, 세션은 서버에 저장됨
  - 쿠키는 만료기간 전까지 남아있지만, 세션은 브라우저가 종료되면 삭제된다.
  - 쿠키는 HTTP 메시지에 담아 보내고, 세션은 서버에서 처리가 필요하기 때문에 요청속도 측면에서는 쿠키가 더 빠르다.

<br>

### :pushpin: Hosting

- 서버의 전체 혹은 일부를 이용할 수 있도록 임대해주는 서비스
- **종류**
  - **웹 호스팅** : 여러 고객이 하나의 서버를 함께 사용하는 형태
  - **서버 호스팅** : 고객이 단독 서버를 사용하는 형태, 서버 운영 및 관리에 대한 직접적인 권한을 가질 수 있다.
  - **클라우드 서버** : 서버 호스팅을 가상화한 것, 가상 서버를 단독으로 사용할 수 있는 형태

<br>

### :pushpin: 부하분산(Load Balancing)

- 컴퓨터 네트워크 기술의 일종
- 둘 혹은 셋 이상의 CPU 또는 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미

<br>



### :pushpin: 프로세스와 스레드

- **프로세스**
  - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램
  - 메모리에 등록되어 실행되고 있는 프로그램의 인스턴스
  - OS로부터 자원을 할당받는 작업의 단위
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역
  - 기본적으로 프로세스당 **최소 1개의 스레드**를 가지고 있음
- **스레드**
  - 프로세스 내에서 실행되는 여러 흐름의 단위
  - 프로세스의 특정한 수행 경로
  - 프로세스 내에서 각각 **Stack 메모리만 할당** 받고, **Code, Data, Heap 영역**은 서로 **공유**한다.

<br>

### :pushpin: 가상 사설 서버(VPS)

- 하나의 물리 서버를 여러 개의 가상 서버로 쪼개어 사용하는 것을 의미
- 쪼개어진 가상 서버를 여러 클라이언트가 나누어 사용하는 것

<br>

### :pushpin: SSL(Secure Socket Layer)란

- 웹 서버와 웹 브라우저간의 보안을 위해 만들어진 보안 기술
- 공개키/개인키, 대칭키 기반 암호화 사용
  - 대칭키 : 세션 키값을 이용해서 대칭키 방식으로 데이터 암호화 
  - 공개키/개인키 : 계산하는데 복잡하고, 시간복잡도가 높으므로 세션 키를 주고 받을 떄 클라이언트가 3 way handshaking 과정에서 받은 웹 서버의 공개키로 세션 키를 암호화하고, 웹 서버는 자신의 개인키로 복호화 한 후에 세션 키를 대칭 키로 하여 암호화 후 데이터 송수신

<br>

### :pushpin: IP주소

- **32bit = 4byte**

- ex) 192.128.1.14 

- 범위가 크기 때문에 총 5개 클래스로 나뉨

  - **유니케스트**할 때 사용하는 클래스 : A, B, C 클래스

    - **유니케스트 : ** 1:1 통신 방식(일반적인 인터넷 응용프로그램이 사용)

  - **A Class** : 0.0.0.0 ~ 127.255.255.255(0 ~ 127)

    - **0**000 0000 ~ **0**111 1111(맨 앞에 비트)

  - **B Class** : 128.0.0.0 ~ 191.255.255.255(128 ~ 191)

    - **10**00 0000 ~ **10**11 1111(맨 앞에서 두 비트)

  - **C Class** : 192.0.0.0 ~ 223.255.255.255(192 ~ 223)

    - **110**0 0000 ~ **110**1 1111(맨 앞에서 세 비트)

    > **128보다 작으면 A 클래스, 191보다 크면 C클래스**

  - **멀티케스트**할 떄 사용하는 클래스 : D 클래스

    - **멀티케스트 : ** 1:N 통신 방식
    - 서브넷 마스크 개념이 없음
    - **D Class** : 224.0.0.0 ~ 239.255.255.255(224 ~ 239)
      - **1110** 0000 ~ **1110** 1111(맨 앞에 네 비트가 1110인 공통 비트를 가진 클래스)

  - **IANA 예비용 예약 주소** 클래스 : E 클래스

    - **E Class** : 240.0.0.0 ~ 255.255.255.255(240 ~ 255)
    - 사용하지 않는 주소, 예비용

- **설정이 불가능한 IP 주소**

  - **예약 주소** : D Class(사용 가능, 설정 불가)
  - **멀티캐스트 주소** : E Class(사용 불가, 설정 불가)
  - **0.x.x.x(0으로 시작하는 주소)** : 사용 불가, 설정 불가
  - **127.0.0.1(루프백 주소)** : 사용 가능, 설정 불가
  - **네트워크 이름, 서브넷 브로드캐스트 주소** : 사용 가능, 설정 불가



<br>

### :pushpin: 서브넷이란?

- 네트워크 아이디와 호스트 아이디를 구별하기 위함(네트워크 아이디당 가질 수 있는 IP 주소 개수)

- **각 클래스와 서브넷 마스크는 상관없음**
  - **/8 서브넷 마스크** : 255.0.0.0
    - **네트워크 아이디** : 0~127
    - **호스트 아이디** : 0.0.0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0.0.0 이므로 2^8승이 3개, 총 2^24승개
  - **/16 서브넷 마스크** : 255.255.0.0
    - **네트워크 아이디** : 128.0 ~ 191.255
    - **호스트 아이디** : 0.0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0.0 이므로 2^8승이 2개, 총 2^16승개
  - **/24 서브넷 마스크** : 255.255.255.0
    - **네트워크 아이디** : 192.0.0 ~ 223.255.255
    - **호스트 아이디** : 0 부분, 한 바이트(8bit)당 가질 수 있는 IP개수는 2^8승
    - **네트워크 아이디당 가질 수 있는 IP 주소 개수** : 네트워크 아이디를 뺀 0 이므로 2^8승이 1개, 총 2^8승 개
  - **ex) IP 주소 : 121.160.54.233, 서브넷 마스크 : 255.255.255.0**
    - 121 이므로 A 클래스
    - A 클래스지만 네트워크 ID를 121.160.54로 사용중
    - A 클래스에 255.0.0.0 서브넷 마스크는 너무 많은 IP 주소를 가지므로 네트워크 ID를 줄이고 적은 호스트 ID를 사용하는 것
  - **ex) 192.168.0.1/24**
    - 192 이므로 C 클래스
    - /24 이므로 255.255.255.0 서브넷 마스크를 가짐
      - 서브넷 마스크 앞에서부터 2^24승 이므로 2^8승이 3개, 255.255.255.0이 되는 것

<br>

### :pushpin: ARP 프로토콜

- 같은 네트워크 대역에서 통신하기 위해 필요한 MAC 주소를 IP를 이용해서 알아오는 프로토콜
  - 같은 네트워크 대역에서 통신할 때는 MAC주소를 통해 통신한다.
- IP주소를 통해 얻은 MAC주소로 상대방과 통신하는 것(상대방의 MAC주소를 모를 때)
- 같은 네트워크 대역에서 통신을 하더라도 7계층부터 캡슐화를 통해 보내기 때문에 IP와 MAC 주소가 모두 필요함, 이때 상대방 MAC주소를 모르더라도 ARP를 통해 MAC주소를 알아오고 통신이 가능해짐
- 요청은 1, 응답은 2로 opcode를 세팅한다.
- **동작 과정**
  - 통신을 요청하고자 하는 컴퓨터에서 ARP 요청 프로토콜을 만듬
    - (이더넷 헤더+ARP요청 프로토콜)
    - 이더넷 헤더 캡슐화 : 목적지 MAC 주소를 FF:FF:FF:FF:FF:FF로 작성(브로드캐스팅)
    - ARP 요청 헤더 헤더 : 이때 출발지 MAC주소와 IP주소는 자신의 것으로 삽입, 목적지 MAC주소는 00:00:00:00:00:00으로 비운다.
  - 2계층 장비인 스위치를 거치기 때문에 이더넷 헤드만 확인하여 같은 네트워크 대역에 브로드캐스팅
  - 해당 패킷을 받은 컴퓨터들은 3계층인 ARP 요청 헤더를 확인
  - 본인의 IP주소와 해당 패킷의 목적지 IP주소가 불일치하면 폐기
  - 자신의 IP주소와 해당 패킷의 목적지 IP주소가 일치하면 이더넷 헤더와 ARP 응답 헤더를 생성
    - 이더넷 헤더와 ARP 헤더에 출발지 MAC 주소에 자신의 MAC주소를 작성함
    - 목적지 MAC 주소는 자신에게 ARP요청 헤더를 보냈던 컴퓨터의 MAC 주소를 기재
  - 이후 통신을 요청한 컴퓨터의 ARP 캐시 테이블에 IP주소와 MAC주소를 등록

<br> 

### :pushpin: 스위치(2계층 장비)

- 패킷의 2계층 까지만 확인