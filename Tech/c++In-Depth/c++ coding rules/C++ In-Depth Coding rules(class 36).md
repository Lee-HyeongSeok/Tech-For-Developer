## C++ In-Depth Coding rules(class 36)

***

<br>

### :pushpin: 기반 클래스로 디자인되지 않은 클래스로부터의 상속을 피하라

클래스 중에는 기반 클래스와는 다른 방식으로 사용되도록 디자인된 것들이 있으며, 이런 독립 클래스들을 기반 클래스로 사용하면 심각한 디자인 오류가 발생할 수 있다. 기능을 추가할 때에는 멤버 함수 대신에 비멤버 함수를 추가하고, 상태를 추가할 때에는 상속성 대신 구조적인 연결을 사용하자.

<br>

### :pushpin: 필요치 않은 곳에 상속성을 사용하는 것은 객체 지향의 힘을 잘못 사용하는 것이다.

C++에서는 기반 클래스를 디자인할 때 특별하게 해주어야 할 일들이 있으며, 이는 독립 클래스와는 상당히 다른 것이다. 따라서 독립 클래스로부터의 상속은 많은 문제를 발생시킬 수 있으며, 컴파일러에서 이를 저지해주는 경우도 드물다.

- 기능을 추가하기 위한 실수
  - string class와 같은 값 클래스로부터 다른 클래스를 얻어내곤 한다.
  - 이때는 비멤버 함수를 정의하는 것이 super_string을 만드는 것보다 훨씬 나은 방법
  - 비멤버 함수는 이미 string을 구현하는 기존 코드 내에서도 잘 작동하기 때문, 만약 super_string을 사용하게 된다면 super_string의 타입과 함수 변화에 따라 코드의 다른 부분 또한 변화하도록 강요하게 된다.
  - super_string을 사용하면 string을 받아들이는 인터페이스 함수가 super_string에 추가된 새로운 기능을 사용하지 않고, 인자를 super_string에 복사해야 하며, string 참조를 super_string 참조로 변환해야 한다.
  - super_string의 멤버 함수는 string의 내부로의 접근이 불가능하지만 비멤버 함수는 가능하다.
  - super_string이 string의 일부 함수를 재정의하거나 감출 경우, string과 연결되어 있던 코드에서 문제 발생 가능

<br>

### :pushpin: 공용 비가상(nonvirtual) 소멸자를 가진 클래스로부터의 상속을 되도록 피하라

string으로의 포인터를 지우는 것이 사실은 super_string 객체로의 포인터일 수 있으며, 이와 같이 불확실한 상태는 컴파일러, 메모리 할당자에 의해 감지되고 보고된다 하더라도 아래와 같은 문제가 생긴다.

- 알 수 없는 오류
- 메모리 leak
- 힙의 변질 등