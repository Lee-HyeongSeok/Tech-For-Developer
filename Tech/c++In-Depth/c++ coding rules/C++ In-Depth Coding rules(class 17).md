## C++ In-Depth Coding rules(class 17)

***

<br>

### :pushpin: 매크로 사용을 자제하라

- 매크로는 C, C++의 추상화 기능 중 가장 무디고 둔감한 것이다.

  > 매크로의 첫 번째 법칙 : 반드시 필요한 경우가 아니면 사용하지 마라

- 매크로의 텍스트 치환 기능이 선처리 과정중에 영향을 미친다.

  > **C++ 문법과 의미 규칙이 적용되기도 전에 미리 그 힘을 발휘한다**

- C++의 목적 중 하나는 C의 선처리 기능을 없애는 것

  > **선처리와 매크로가 오류의 온상이 되기 때문**

- 매크로는 C++에서 불필요한 요소이다.

  > [1] 명확한 상수를 정의할 때는 const나 enum을 쓰면 된다.
  >
  > [2] 함수 호출 오버헤드를 피하고자 할 때에는 인라인을 사용하면 된다.
  >
  > [3] 함수의 집합과 타입을 지정할 때에는 템플릿을 사용하면 된다.
  >
  > [4] 이름 사이의 충돌을 막고자 할 때에는 네임스페이스를 사용하면 된다.

<br>

### :pushpin: 매크로의 문제점

- 범위를 무시한다.

- 타입 시스템을 무시한다.

- 다른 언어 기능의 규칙을 무시한다.

- 파일의 나머지 부분에서 #define된 부분을 무시한다.

- 매크로의 형식은 심볼이나 함수 호출과도 비슷하지만 실제로는 그렇지 않으며, 예상 외로 그 범위가 커질 수 있기 때문에 불안정하다.

- 매크로가 수행하는 텍스트 치환 기능은 아무리 잘 쓰여진 매크로라고 할지라도 그 보상을 애매하고 장황하게 만들어버린다.

- **템플릿**은 C++ 타입 시스템의 일원이며, 컴파일러의 제어를 돕는 기능이 있지만, **매크로**는 언어와 별개의 것으로 항상 괴리되어 있다.

  > :point_right: 매크로는 예상치 못한 부분으로 확장될 수 있으며, 확장되기 전에는 오류를 보고 받기 힘들다.

<br>

### :pushpin: 매크로를 사용한 템플릿 인스턴스 만들기

```c++
MARCRO(Foo<int, double>)
```

- 매크로는 C의 괄호 체계를 충분히 이해하고 활용하기 힘들다.
- C++에서는 템플릿 내에 <, > 괄호를 넣어 사용할 수 있지만, 매크로가 정확하게 이해하지 못한다.
- 위 매크로는 Foo<int와 double>이라는 두 변수가 전달된 것으로 인식해버린다.

<br>

### :pushpin: 매크로를 사용하는 예외적인 상황

- #include 가드, 조건부 컴파일에 필요한 #ifdef와 #if 등과 같은 몇 가지 중요한 작업에 있어 매크로가 유용하게 사용되는 경우가 있다.
- 조건부 컴파일의 경우(시스템에 의존하는 부분) : #ifdef를 사용해서 코드를 더럽히지 말고, 차라리 매크로를 활용하여 코드를 작성하여 공용 인터페이스를 구현하고, 그 인터페이스를 거치도록 하는 것이 좋다.
- 코드의 일부를 복사하여 붙여 넣는 작업의 경우 매크로를 사용하는 것도 하나의 방법이다.