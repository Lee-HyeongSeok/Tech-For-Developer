## C++ In-Depth Coding rules(class 22)

***

<br>

### :pushpin: 컴파일 단위 사이의 초기화 의존성을 없애라

- 초기화 순서를 지켜라

- 서로 다른 컴파일 단위 내에 존재하는 네임스페이스 레벨의 객체는 초기화 순서가 정해져 있지 않기 때문에 절대 서로 의존해서는 안 된다.

- 프로젝트 내에 변경된 내용이 있을 때 호환성 문제 등 같은 컴파일러로 새로 빌드한다고 해도 다양한 문제가 발생하게 된다.

- 서로 다른 컴파일 단위 내에서 각각의 네임스페이스 레벨 객체를 정의하고 만약 어떤 객체의 생성자가 먼저 호출되어야 하는지가 정해져 있지 않다면, 컴파일 단위의 객체 파일이 연결된 순서대로 초기화가 이루어진다.

  > 이러한 과정은 그리 신뢰할 만한 수준은 아니며, 코드의 정확성이 외부의 파일에 의해 결정되는 것은 좋은 방법이 아니다.
  >
  > :point_right: 네임스페이스 레벨의 객체에 대한 초기화 코드 내에서 다른 컴파일 단위의 객체가 이미 초기화되었다는 가정을 할 수 없게 된다.
  >
  > :point_right: 이러한 고려 사항은 기본 타입의 변수에 대한 동적인 초기화에 적용되어, 
  >
  > ```c++
  > bool reg_success = LibRegister("mylib");
  > ```
  >
  > 와 같은 네임스페이스 레벨의 초기화 시 활용된다.

<br>

### :pushpin: 초기화 의존성의 문제점

- 생성자를 통해 만들어지기 전에 네임스페이스 레벨의 객체가 모두 0의 값으로 초기화될 수 있다.
  - 이러한 초기화는 프로그램의 큰 실행 흐름에는 해를 끼치지 않지만 찾아내기 힘든 버그를 만들어낼 수도 있다.
  - ex) 문자열이 비어 있다거나 포인터가 null이거나 정수가 0일 것이라 생각하겠지만, 아직 초기화되지 않은 변수일 수도 있다.

<br>



### :pushpin: 해결 방안

- 네임스페이스 레벨의 변수를 가능하면 사용하지 않아야 한다.

- 의존하는 변수가 필요하다면 싱글톤(Singleton) 디자인 패턴을 사용하는 것도 하나의 방법이다.

  > 첫 번째 접근 시 객체의 초기화가 이루어지기 때문
  >
  > :point_right: 싱글톤 역시 전역 변수이며 상호 의존성에 의해 파괴될 수 있기 때문에 조심해서 사용해야 한다.