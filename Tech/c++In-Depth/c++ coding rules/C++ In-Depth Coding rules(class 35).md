## C++ In-Depth Coding rules(class 35)

***

<br>

### :pushpin: 상속성은 주의해서 사용하라

상속성은 C++에서 두 번째로 강한 결합 형태이며, 강한 결합은 가능한 피해야 한다. 따라서 디자인상의 분명한 이점이 보장되지 않는 경우라면 상속성보다는 구성상의 혼합 형태를 사용하는 것이 좋다.

- 소프트웨어 엔지니어링의 중요한 규칙 중 하나는 결합 최소화이다.
- 둘 사이의 관계가 여러 방식으로 표현 가능하다면 결합력이 약한 형태를 사용하는 것이 좋다.
- 보다 약한 결합 형태의 사용이 불가능한 상황일 경우에만 상속성을 사용하자.
- 적절한 구성상의 연결을 통해 클래스 관계를 표현할 수 있을 때는 그 방법을 사용해야 한다.
  - 구성상의 연결 : 타입의 멤버 변수를 다른 타입에 첨가시키는 것
  - 연결의 장점을 살리면서 객체를 사용 가능

<br>

### :pushpin: 상속성에 비해 구성상의 연결이 가지는 장점

- 호출 코드에 영향을 미치지 않는 유연성
  - private 데이터 멤버를 개발자가 제어 가능
  - 클라이언트 코드에 영향을 주지 않고서도 값에 의한 사용에서 스마트 포인터나 핌플(pimpl)에 의한 사용으로 전환할 수 있다.
  - 클래스의 자체 멤버 함수에 대한 구현체만 바꿔주면 되기 때문이다.
  - 만약 상속성을 사용할 경우 클라이언트가 이미 상속성에 의존하게 되므로, 클래스 역시 거기에 맞게 따라가야 하기 때문에 이후에 기본 클래스를 수정하는 일이 쉽지 않다.
- 컴파일 시의 이점
  - 직접적인 멤버나 기반 클래스가 아닌 포인터에 의한 객체 홀딩을 사용하면 객체 클래스 정의가 필요하지 않으므로 그만큼 헤더의 의존성을 줄일 수 있다.
  - 상속성은 기반 클래스의 전체 정의가 항상 필요하다. 이를 위해 자주 사용되는 기술로는 하나의 포인터로 모든 private 멤버를 결합시키는 방식이 있다.
- 혼란의 방지
  - 하나의 타입에서 상속이 이루어지면 함수 내의 이름 조회가 필요하고, 함수 템플릿 역시 같은 타입의 같은 네임스페이스 내에서 정의되어야 한다는 제한 사항이 있다. 이는 혼란을 주고 디버그가 힘들어진다.
- 보다 넓은 활용성
  - 기반 클래스로서 사용되게끔 디자인되지 않은 클래스들도 있지만, 대부분 멤버로서의 역할은 문제없이 수행한다.
- 튼튼하고 안전한 코드의 작성
  - 상속성의 강한 결합력은 오류로부터 안전한 코드 작성을 힘들게 한다.
- 보다 간결한 방식
  - 상속성은 이름의 숨김 등과 같은 부가적이고 복잡한 문제들을 발생시키며, 기반 클래스의 변화와 같은 이후의 수정이 필요할 경우 코드 전체가 복잡해진다.