## C++ In-Depth Coding rules(class 42)

***

<br>



### :pushpin: 특징 없는 값의 집합(C 스타일의 struct)을 제외하고는 모든 데이터 멤버를 사영으로 유지하라

- C 스타일의 struct 타입과 같이 캡슐화나 특정한 기능과 관련이 없는 값들의 모임일 경우를 제외하고는 데이터 멤버를 사영으로 유지하라.
- 공용 데이터와 사영 데이터를 혼합하는 것은 디자인에 좋지 않다.

<br>



### :pushpin: 정보를 숨기는 것은 좋은 소프트웨어 엔지니어링의 핵심이다.

- 사영 데이터는 클래스가 자신의 불변성을 유지하는 데 활용해야 한다.
  - 이후 변화에 대응하기 좋기 때문
- 클래스가 추상화로 설계되어야 하고 그 불변성이 유지되어야 한다면 공용 데이터는 적절하지 않다.
- 공용 데이터를 가진다는 것은 클래스 일부의 상태가 그 클래스의 나머지 부분의 상태에 따라 완전히 제어, 예측 불가능하게 되거나, 비동기적으로 변할 수 있음을 의미한다.
  - 추상화를 사용해서, 하나 또는 그 이상의 불변성을 유지하는 것에 대한 책임을 추상화를 사용한 수많은 모든 코드의 집합과 함께 공유한다는 의미이다. (좋은 디자인이 아니다.)

<br>



### :pushpin: 보호된 데이터는 공용 데이터의 모든 약점을 가진다.

- protected 데이터를 가진다는 것도 추상화가 어떤 불변성 유지에 대한 책임을 수많은 코드집합들과 함께 공유한다는 것을 의미하기 때문이다.
- protected 데이터의 경우에는 현재의 클래스뿐만 아니라 앞으로 파생될 클래스들까지도 포함하게 되며, 임의의 코드가 파생되는 새로운 클래스에 의해 protected 데이터를 public 데이터보다 더 쉽게 읽거나 수정할 수 있고 그 데이터를 사용할 수도 있다는 것이다.

<br>



### :pushpin: 공용 데이터와 사영 데이터를 같은 클래스에서 함께 사용하는 것은 혼란스럽고 모순적인 것이다.

- 사영 데이터는 개발자가 불변성을 가지고 그것들을 보호할 목적으로 사용한다는 것을 나타낸다.
- 이를 공용 데이터와 함께 사용한다는 것은 그 클래스를 정말로 추상화시킬 것인지 아닌지조차 명확하게 결정하지 못한다는 의미가 된다.

<br>



### :pushpin: 사영 멤버로 클래스의 은닉/은폐를 고려한다면 Pimple을 사용하라

1. 적절한 캡슐화
   - 대부분의 클래스는 사영 데이터 멤버를 가지며, 적절한 인터페이스를 제공한다.
   - 외부 코드는 이런 인터페이스를 통해 클래스와 교류하며, 클래스가 가진 기능에 접근하여 활용한다.
2. TreeNode
   - TreeNode\<T>를 기반으로 구현된 Tree\<T> 컨테이너가 있다고 가정한다.
   - TreeNode\<T>는 Tree 내의 이전/다음/상위 포인터와 T 객체를 담는 것이라고 할 때, TreeNode의 멤버는 Tree로부터 숨겨질 필요가 없고 직접 제어할 수 있으므로 모두 공용으로 제정될 수 있다.
   - 하지만 Tree는 TreeNode를 함께 숨겨야 하며, 이는 호출자가 신경 쓸 부분이 Tree의 내부 내용이 아니기 때문이다.
   - 한편 Tree는 T 객체를 숨겨서는 안 되는데, 이는 호출자가 이를 통해 클래스의 기능을 활용하기 때문이다.
3. get과 set
   - 적절한 추상화가 이루어지지 않는다면 공용 및 보호된 데이터 멤버는 사영으로, 그리고 get과 set 함수에 숨겨야 한다.
   - 외부 노출 단계를 구체적인 상태에서 추상적인 상태로 끌어올리는 것은 그만큼 개발자가 원하는 대로 제어할 수 있게끔 만든다는 것이다.