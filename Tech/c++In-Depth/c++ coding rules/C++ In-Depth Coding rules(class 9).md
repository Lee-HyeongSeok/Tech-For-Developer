## C++ In-Depth Coding rules(class 9)

***

<br>

### :pushpin: 이른 최적화를 피하라

- 서두른 최적화는 비효율적이고 비생산적이다.

- **최적화의 규칙**

  1. 최적화를 하지 말라
  2. 아직 최적화를 하지 말라

  > **두 번 측정하고, 한 번 최적화하라**

<br>

### :pushpin: 너무 이른 최적화의 단점

- 디자인과 코드를 보다 복잡하게 만들고 읽기 힘들게 한다.
- 성능 면에서 이점이 있다고 해도 최종 목적과 비교한 정확한 성능 측정을 통한 이점이 아니라면 문제가 된다.
- 불필요하고 정확히 검사되지 않은 최적화 시도는 프로그램을 전혀 빠르게 해주지 못할 수도 있다.

<br>

> **빠른 프로그램을 올바르게 수정하는 것보다 올바른 프로그램을 빠르게 만드는 것이 더 쉽다.**

<br>

### :pushpin: 이른 최적화를 진행한다고 해서 반드시 프로그램이 빨라지는 것은 아니다.

- 프로그래머가 코드의 속도와 크기를 따지고 병목 현상을 찾는 것은 힘들다.
  - 대부분의 CPU가 가진 일반적인 처리 방식을 컴파일러는 완벽히 이해하지 못한다.
  - 개발자가 작성한 소스 코드가 기계어로 변경되면 가장 최적의 성능을 가질 것인지를 예측할 뿐이다.
  - 개발자의 예측은 컴파일러보다 못할 때가 많다.
  - 단지 추측을 기반으로 코드의 효율성을 따지는 와중에 어떤 변화가 더 나은 것인지 판단하고 미세한 최적화를 이룬다는 것은 상당히 힘들다.
  - 그러므로 최적화는 반드시 측정 이후에 이루어져야 한다.
  - 완벽한 증거가 없다면 사람이 읽기 편한 코드를 작성하는 데 노력하는 것이 차라리 낫다.
- CPU의 경계 외부에서 이루어지는 작업이 늘어나고 있다.
  - CPU의 성능 뿐만 아니라 메모리, 네트워크, 디스크, 웹 서버 대기 시간, 데이터베이스 대기 시간 등의 효율을 따져야 하는 경우가 많다.
  - CPU보다 빠르게 실행할 수 있는 최적화를 한다고 해도 외부적 요인에 의해 실제 실행 속도는 거의 차이가 없을 수 있다.

<br>

### :pushpin: 코드의 최적화가 필요한 시기에 필요한 것

> [1] 알고리즘의 최적화를 먼저 생각
>
> [2] 모듈화와 캡슐화를 시도
>
> [3] 최적화의 이유가 무엇이며 어떤 알고리즘을 참조한 것인지를 명확히 해둔다.

<br>

### :pushpin: 참조에 의한 전달

> 이른 최적화라 보기 힘들다.

- 가능한 ++과 -- 접두어를 사용

- 즉시 이해하고 수정할 수 있는 간편한 구조를 사용

  > 이런 과정은 오히려 이른 최적화를 피하는 방법이다.