## 제네릭 알고리즘의 사용

***

<br>

### :pushpin: 제네릭 검색 알고리즘

- find()

  - first와 last 반복자로 표시되는 무순서의 모음에서 특정값을 검색
  - 값이 발견되면 값을 가리키는 반복자를 반환, 그렇지 않으면 last를 가리키는 반복자를 반환

- binary_search()

  - 정렬된 모음에서 검색
  - 값이 발견되면 true, 그렇지 않으면 false 반환
  - find()보다 효율적

- count()

  - 값과 일치하는 요소의 개수를 반환

- search()

  - 컨테이너 내에서 뒤따르는 연속된 값을 비교

    > ex) {1, 3, 5, 7, 2, 9}가 주어졌을 때 {5, 7, 2}를 검색하면 연속된 값의 처음을 가리키는 반복자가 반환

  - 연속된 값이 발견되면 연속된 값의 처음을 가리키는 반복자가 반환, 그렇지 않으면 컨테이너의 마지막을 가리키는 반복자 반환

<br>

### :pushpin: 벡터가 오름차순으로 정렬되어 있음을 보증할 때 binary_search()가 가장 훌륭한 선택이다

```c++
#include <algorithm>

bool is_elem(vector<int> &vec, int elem){
    // binary_search()를 호출하기 전에 수열을 확장시킬 필요가 있는지 검사해야 한다.
    // 즉, 수열이 elem를 포함할 만큼의 충분한 요소를 갖고 있는지 검사해야 한다.
    // 수열에서의 가장 큰 요소와 elem을 비교하면 된다.
    return binary_search(vec.begin(), vec.end(), elem);
}
```

> :point_down: 수열에서 가장 큰 요소를 결정하는 max_element() 제네릭 알고리즘을 통한 향상된 코드
>
> max_element() : 탐색하고자 하는 요소의 구간을 반복자로 넘긴다(벡터 내에서 가장 큰 요소를 반환)

```c++
#include <algorithm>
extern bool grow_vec(vector<int>&, int);

bool is_elem(vector<int> &vec, int elem){
    vector<int>::iterator max_value;
    int max_value = max_element(vec.begin(), vec.end());
    // int max_value = vec.empty() ? 0 : vec[vec.size()-1];
    
    if(max_value < elem)
        return grow_vec(vec, elem); // 수열에서 요소가 elem과 같거나 클 때까지 벡터에 요소를 추가
    if(max_value == elem)
        return true;
    return binary_search(vec.begin(), vec.end(), elem);
}
```

