## 템플릿 프로그래밍 - 가변 길이 템플릿

***

<br>

### :pushpin: 템플릿 파라미터 팩(parameter pack)

```template <typename T, typename... Types>```

위 코드에서 typename 뒤에 ```...```으로 오는 것을 템플릿 파라미터 팩(parameter pack)이라고 한다.

템플릿 파라미터 팩의 경우 0개 이상의 템플릿 인자들을 나타낸다.

<br>

### :pushpin: sizeof 연산자와 sizeof... 파라미터 팩

- sizeof 연산자

  > 인자의 크기를 리턴

- sizeof... 파라미터 팩

  > 전체 인자의 개수를 리턴

<br>

### :pushpin: 원소들의 평균을 구하는 함수

```c++
#include <iostream>
using namespace std;

int sum_all(){ return 0; }

template <typename... Ints>
int sum_all(int num, Ints... nums){
    return num+sum_all(nums...);
}

template <typename... Ints>
double average(Ints... nums){
    return static_cast<double>(sum_all(nums...)) / sizeof...(nums);
}

int main(){
    cout<<average(1, 4, 2, 3, 10)<<endl; // 결과 4
}
```

> ```sum_all()``` 함수는 전달된 인자들의 합을 리턴하는 함수
>
> ```average()``` 함수의 경우 전달된 전체 인자의 개수로 합을 나눠줘야만 한다.
>
> 요기서 sizeof... 연산자가 활용되는데, ```sizeof...```에 파라미터 팩(nums)를 전달하면 nums에 해당하는 실제 인자의 개수를 리턴해준다.

<br>

### :pushpin: Fold Expression

```c++11``` 에서 도입된 가변 길이 템플릿은 매우 편리하지만 단점이 있다.

**재귀 함수 형태로 구성해야 하기 때문에, 반드시 재귀 호출 종료를 위한 함수를 따로 만들어야 한다.**

```c++
int sum_all(){ return 0; } // 재귀 호출 종료를 위한 베이스 케이스
```

위에서 만들었던 ```sum_all()``` 함수를 살펴보면 재귀 함수 호출을 종료하기 위해 베이스 케이스를 꼭 만들어줘야 한다

:point_right: 이는 코드의 복잡도를 늘리게 된다.

<br>

하지만 ```c++17``` 에 새로 도입된 Fold 형식을 사용한다면 훨씬 간단하게 표현할 수 있다.

```c++
#include <iostream>
using namespace std;

template <typename... Ints>
int sum_all(Ints... nums){
    return (... + nums);
}

int main(){
    cout<<sum_all(1, 4, 2, 3, 10)<<endl; // 결과 20
}
```

```return (... + nums)``` 이 문장이 C++ 17에 추가된 Fold 형식으로, 

```return ((((1+4) + 2) + 3) + 10)``` 이와 같이 컴파일러에서 해석된다.

이와 같은 형태를 단항 좌측 Fold(Unary left fold)라고 부른다.

<br>

### :pushpin: ```C++17```에서 지원하는 Fold 방식의 종류

> ```I``` 는 초기값을 의미, 파라미터 팩이 아니다.
>
> ```op``` 자리에는 대부분의 이항 연산자들이 포함될 수 있다(+, -, <, <<, ->, , 등등)
>
> Fold 식을 쓸 때 꼭 ```()```로 감싸줘야 한다.
>
> ```return (... + nums);``` 대신에 ```return ... + nums;``` 로 컴파일 하게 된다면 오류가 발생한다.
>
> :point_right: ```()```는 Fold 식에 포함되어 있는 것

| 이름            | Fold 방식      | 실제 전개 형태                      |
| --------------- | -------------- | ----------------------------------- |
| (E op ...)      | 단항 우측 Fold | (E1 op (...op(E2 op EN)))           |
| (... op E)      | 단항 좌측 Fold | (((E1 op E2) op E3) op En)          |
| (E op ... op I) | 이항 우측 Fold | (E1 op (... op(En-1 op (En op I)))) |
| (I op ... op E) | 이항 좌측 Fold | ((((I op E) op E2) op ...) op En)   |

<br>

이항 Fold의 경우 예시

```c++
#include <iostream>
using namespace std;

template <typename Int, typename... Ints>
Int diff_from(Int start, Ints... nums){
    return (start - ... - nums);
}

int main(){
    cout<<diff_from(100, 1, 4, 2, 3, 10)<<endl; // 결과는 80
}
```

```return (start - ... - nums);``` 에 따르면 이항 좌측 Fold이다.

start는 초기값 ```I```이고 nums가 파라미터 팩 부분이기 때문

위 식은 실제로 ```return (((((100 - 1) - 4) - 2) - 3) - 10); ``` 이 된다.

<br>

```,``` 연산자를 사용하면 각각의 인자들에 대해 원하는 식을 실행 가능하다.

```c++
#include <iostream>
using namespace std;

class A{
    public:
    void do_something(int x) const{
        cout<<"do something with "<<x<<endl;
    }
};

template <typename T, typename... Ints>
void do_many_things(const T& t, Ints... nums){
    (t.do_something(nums), ...); // , 연산자를 이용
}

int main(){
    A a;
    do_many_things(a, 1, 3, 2, 4);
}
```

```(t.do_something(nums), ...);``` 이는 모든 인자들에 대해 각각 ```t.do_something(arg)```를 실행한 것과 같다.

실제 컴파일 되는 코드는 

```t.do_something(1);```

```t.do_something(3);```

```t.do_something(2);```

```t.do_something(4);```

를 실행한 것과 같다.